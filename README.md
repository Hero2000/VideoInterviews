## JNI知识点
### 动态注册 vs 静态注册
执行一个java的native方法，要想让虚拟机知道调用so库中的哪一个方法，需要知道native方法和so库中对应的函数映射表，如何将native方法和so库中函数映射起来，就用到了注册的概念。
注册分为动态注册和静态注册，默认情况下是静态注册，我们不需要管。
#### 静态注册
通过JNIEXPORT和JNICALL两个宏定义声明，在虚拟机加载so的时候通过这两个宏定义来查找对应的native方法。
通常的命名规则是：Java_包名_类名_方法名

静态注册的优点：
> * 非常简单明了，开发者只要遵循jni的规则就行，不需要额外的费事了

缺点：
> * 必须按照特定的命名规则
> * 函数的名字太长了
> * 运行时效率不高
#### 动态注册
动态注册，顾名思义，就是在运行过程中通过调用RegisterNatives方法手动实现native方法和so中方法的绑定，虚拟机可以通过函数映射表直接找到对应的方法。
实现动态注册的地方是JNI_OnLoad方法，这是so加载的入口。如果动态注册成功返回JNI_OK，失败则返回一个负的值。

### JavaVM vs JNIEnv
JavaVM 代表java的虚拟机，Android中一个进程只有一个JavaVM，我们so加载的入口就是JNI_OnLoad(JavaVM* jvm, void* reverved)

JNIEnv是提供JNI Native函数的基础环境，不同的线程的JNIEnv相互独立的。

在native层中，想要获得当前线程所使用的JNIEnv，可以使用Dalvik虚拟机对象的JavaVM* jvm->GetEnv()返回当前线程的JNIEnv*
### JNI中多线程回调到Java层如何实现
从上面的分析已经得知JavaVM是进程相关的，JNIEnv是线程相关的，可以通过JavaVM->AttachCurrentThread获取子线程的JNIEnv引用，在调用结束之后，通过JavaVM->DetachCurrentThread()解除挂在当前的线程。

### 局部引用 vs 全局引用
#### 局部引用
通过NewLocalRef和各种JNI接口创建，例如可以通过FindClass/NewObject/GetObjectClass等JNI接口创建，不能再本地函数中跨函数调用，也不能跨线程使用，函数返回中局部引用的对象会被JVM自动释放，也可以调用DeleteLocalRef释放。

形成一个良好的开发习惯，在创建了局部引用之后，如果已经使用过了，还是建议手动释放。
#### 全局引用
通过调用NewGlobalRef创建，可以跨方法、跨线程使用，JVM不会自动释放，必须要使用DeleteGlobalRef手动释放。
#### 弱全局引用
通过调用NewWeakGlobalRef创建，一般情况下引用不会自动释放，当内存比较紧张的情况下，JVM也会回收它的，可以通过DeleteWeakGlobalRef手动释放。
## MediaCodec知识点
### MediaCodec同步 vs 异步
### MediaCodec工作原理
### MediaCodec解码导致绿边问题
### MediaCodec如何提升清晰度
## 音视频基础知识点
### H264编码流程
#### H264压缩技巧
H264压缩技术主要采用了以下几种方法对视频数据进行压缩：
> * 帧内预测压缩，解决的是空间数据冗余的问题
> * 帧间预测压缩，就是运动估计与补偿，解决是时域数据冗余的问题
> * 整数离散余弦变换（DCT），将空间上的相关性变为频域上无关的数据进行量化处理
> * CABAC压缩

经过压缩后的帧分为：I帧、P帧、B帧
> * I帧：关键帧，采用的帧内压缩技术
> * P帧：向前参考帧，在压缩时，只参考前面已经处理过的帧
> * B帧：双向参考帧，在压缩时，参考前面的帧，又参考后面的帧，采用帧间压缩技术

一个GOP：Group of pictures，一组图像序列，两个I帧之间是一个图像序列。

#### H264压缩过程
> * 原始数据送到H264编码器的缓冲区，编码器为每一帧图片划分宏块。
> * H264默认使用16 * 16 大小的区域作为一个宏块，划分好宏块，计算宏块的像素值，进而计算每一帧图片中所有宏块的像素值
> * 在宏块的基础上划分更小的子块，子块大小可以自选，但是要求比宏块更小
> * 进行帧分组，视频数据有时间上的数据冗余和空间上的数据冗余，时间上的数据冗余比较大。相邻帧的图片差异不会很大。这样我们就推出了I帧、B帧、P帧的概念
> * 运动估计与补偿
> * 帧内预测
> * 对残差数据做DCT
> * CABAC，属于无损压缩技术

### H264 vs H265
H265仍然采用混合编解码，编解码结构与H264基本一致。
主要提升在于：
> * 编码块划分结构：采用CU/PU/TU的递归结构
> * 并行工具：增加了Tile以及WPP等并行工具集以提高编码速度
> * 滤波器：在区块滤波之后增加了SAO滤波模块
> * H265优化了实现细节，对高清视频的处理更加精细

### FLV格式介绍
### TS格式介绍
### MP4格式介绍
### HLS格式介绍
### DASH格式介绍
### RTMP协议分析
## Android基础知识
### Dalvik vs ART
### GC Root有哪些
## 播放器知识点
### 播放器架构分析
### 播放器成功率优化
### 播放器首帧速度优化
### 播放器卡顿优化
## FFmpeg知识点